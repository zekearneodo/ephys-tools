
function cc = concentration_calibration_pid()
% global cc

% include the folder where the common files are usually located
[~,computerName]=system('hostname');
if ~strcmp(strtrim(computerName),'flipper')
    includePath=fullfile(fileparts(pwd),'current','include');
    addpath(includePath);
end

    cc.pid_analysis       = @pid_analysis;
    cc.calculate_calibration = @calculate_calibration;
    cc.check_calibration  = @check_calibration;
    cc.pid_get            = @pid_get;
    cc.pid_all_series     = @pid_all_series;
    cc.pid_multi_graph    = @pid_multi_graph;
    cc.pid_max_graph      = @pid_max_graph;
    cc.pid_graph          = @pid_graph;
    cc.pid_graph_all      = @pid_graph_all;
    cc.pull_data          = @pull_data;
    cc.vial_lookup        = @vial_lookup;
    cc.subplot_fig        = @subplot_fig;
    
end
%%%% concentration_calibration_pid
%   PID concentration calibration using air flow adjustments
%   2015-02-14
%   KP: procedure to calculate the air dilutions to create the desired
%   concentrations, correction for mineral oil signal, other improvements 
%   CW,ZK: core from data_managment tools_pid

%This set of functions reads h5 files generated by Voyeur with the pid
%trace recorded in the sniff channel, and performs some analyses.
%Assumes the file structure is the same as for ephys (mouse_sess).
%It looks for x_yy_*_pid.h5 files (x rec, yy run).

%  pid_analysis(mouse,sess,stat) 
%If stat is specified input arg, the data will be pulled from the remote
%station. Otherwise assumes it's already on the local server.
%Gets the pid data and stimulus data from h5 file and parses it by trial.
%Then goes through each odor, vial, and concentration, and normalizes
%the baseline, subtracts the mineral oil signal, plots traces, measures the 
%average amplitude within a measurement segment, fits the [conc, pid amp]
%datapoints with a power law relationship for each vial, and stores these
%analyses in a struct called pidAn.
%Last, does the final calculations of calibrating the correct N2:air flow
%rates to match the highest conc stimulus to the neat odor reference and
%then create additional stimuli at concentrations each 10-fold lower.

%  -pid_get(mouse,sess,rec) gets the h5 files for a pid, sess, all the recs,
% and leaves it into a trial structure trPid.
%  -pid_all_series(trPid) 
% The function called by pid_analysis to plot the traces and do initial
% calculations.
%     -[concPlot]=pid_multi_graph( tr_pid, odor, conc, vialConc, dillution, trPidMO, suppress_graphs)
%    Called by pid_all_series. For a single odor, goes through each
%    stimulus (vials, dilutions, concentrations), calls pid_graph to do the
%    calcutions, and plots the outputs in two figures. 1-all pid traces
%    overlayed, colored by vial. 2-pid amplitudes for each concentration
%    measured (in log space) with power law fits by vial
%    Saves all relevant attributes in struct PidAn.concPlot


function [calResult,pidAn,trPid] = pid_analysis(pid,sess,trPid,stat)
%pull_pid_data
%pid_get
%pid_all_series
%calculate_calibration
% fontsz = 14;
set(0,'DefaultAxesFontSize',14)
global N_tr lost_trials

%Pull the data from remote station if stat was included as an input argument
if nargin>3 && ~isempty(stat) && ~strcmp(stat,'local')
    pull_data(pid,sess,stat); %pid files must end with _pid.h5
end

% N_tr = 5;

%%%%%
%Get the pid traces and plot by odor and vial. 
pidAn = struct();
recList=['a'];
for ir=1:numel(recList)
    if ~exist('trPid','var')
        trPid=pid_get(pid,sess,recList(ir));
    end
    pidAn(ir).pidname = pid;
    pidAn(ir).sess=sess;
    pidAn(ir).rec=recList(ir);
    pidAn(ir).odors=pid_all_series(trPid);
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Choose whether you want to run calibration program or stimulus check
prompt = 'Press ENTER to run calibration, or type 1 to run check, or 0 to end here.\n';
call_program = input(prompt); fprintf('\n')
% call_program = [];
if isempty(call_program) %Call function to calculate flow rates 
    calResult = calculate_calibration(pidAn);
    
elseif call_program == 1 %Call function to check pid traces 
    calResult = check_calibration(pidAn);
    
elseif call_program == 0
    calResult = struct();
    return
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
end



function calResult = calculate_calibration(pidAn)
% output: struct of calibration parameters
    % odor name
    % vials (3)
        % vialConc
        % N2 flow rate
        % derived conc
        % matched pid amplitude
global N_tr flow_results

calResult = struct();
for io = 1:numel(pidAn.odors)
    if strncmp('mineral_oil',pidAn.odors(io).odor,6)  %only perform analyses on odor stimuli
        continue
    end
    fprintf('\n***************************\n%s\n\n',strtrim(pidAn.odors(io).odor{1}))

    vials = struct();
    for iv = 2:numel(pidAn.odors(io).vialConc)
        if iv==2
            try %if neat vial was included in recording
                if strncmp('2-hydroxyacetophenone',strtrim(pidAn.odors(io).odor{1}),6)
                    ref_neat_conc_i = find(pidAn.odors(io).concPlot.conc  ==  single(0.053));
                elseif strncmp('menthone',strtrim(pidAn.odors(io).odor{1}),6)
                    ref_neat_conc_i = find(pidAn.odors(io).concPlot.conc  ==  single(0.038));
                end
                % Find the voltage to match
                P_target = pidAn.odors(io).concPlot.amp(pidAn.odors(io).vialConc==single(1),ref_neat_conc_i);
                
            catch %%%%%%%%%%%% Make backwards compatible!!!
                pidAn.odors(io).concPlot.concs
                error('For now, run  * concentration_calibration_pid_oldMO *  on this session.')
            end
            
            % Know target PID amp from neat, now find flows of V0 to match
            [Z_conc(iv), set_N2_flow] = PL_solve_for_conc(pidAn.odors(io).concPlot.fitParams(iv,:),P_target,pidAn.odors(io).vialConc(iv));
            
        else
            % amplitude of highest flow of next vial
            nextV100_amp = pidAn.odors(io).concPlot.amp(iv,find(~isnan(pidAn.odors(io).concPlot.amp(iv,:)),1,'last'));
            % where [in C] does it correspond to on the previous vial?
            nextV100_conc_fraction = PL_solve_for_conc(pidAn.odors(io).concPlot.fitParams(iv-1,:),nextV100_amp,pidAn.odors(io).vialConc(iv-1)) / Z_conc(iv-1);
            % how much further do you need to dilute from the highest
            % flow?
            further_dil = .1/nextV100_conc_fraction;
            Z_conc(iv) = further_dil * pidAn.odors(io).concPlot.conc(find(~isnan(pidAn.odors(io).concPlot.amp(iv,:)),1,'last'));
            set_N2_flow = round(100*further_dil);
            
            P_target = PL_solve_for_PIDamp(pidAn.odors(io).concPlot.fitParams(iv,:),Z_conc(iv));
        end
        
        fprintf('vial: %4.6f\n  set N2:air flows to: %i:%i\n',pidAn.odors(io).vialConc(iv),set_N2_flow,1000-set_N2_flow)
        
        vials(iv-1).vialConc = pidAn.odors(io).vialConc(iv);
        vials(iv-1).N2_flow = set_N2_flow;
        vials(iv-1).derived_conc = Z_conc(iv);
        vials(iv-1).PID_amp_match = P_target;
        vials(iv-1).PL_fit_params = pidAn.odors(io).concPlot.fitParams(iv,:);
    end %for iv = vials
    
    calResult(io).odor = strtrim(pidAn.odors(io).odor{1});
    calResult(io).vials = vials;
end
aaa=234;
end



function [Z_lower, set_N2_flow] = PL_solve_for_conc(fitParams_lower,P_higher,vialConc_lower)
% Find concentration that matches a specified pid amplitude.
% Z_lower = (10^(log10(P_higher/fitParams_lower(1))/fitParams_lower(2)));
Z_lower = (P_higher/fitParams_lower(1))^(1/fitParams_lower(2));
set_N2_flow = round(Z_lower/vialConc_lower*1000);
end

function [P_higher] = PL_solve_for_PIDamp(fitParams_higher,Z_target)
% Find pid amplitude that matches a specified concentration.
P_higher = fitParams_higher(1).*(Z_target.^fitParams_higher(2));
end



function result = check_calibration(pidAn)
result = struct();
for io = 1:numel(pidAn.odors)
    if strncmp('mineral_oil',pidAn.odors(io).odor,6)  %only perform analyses on odor stimuli
        continue
    end
    fprintf('\n***************************\n%s\n\n',strtrim(pidAn.odors(io).odor{1}))
    
    amplitudes = pidAn.odors(io).concPlot.ampDistr;
    
    mean_amps = pidAn.odors(io).concPlot.amp;
    mean_amps_list = flipud(mean_amps(~isnan(mean_amps)));
    PID_traces = pidAn.odors(io).concPlot.PIDtraces;
    std_traces = pidAn.odors(io).concPlot.stdtraces;
    
    ind = 1;
    for iC = 2:2:2*(size(mean_amps,1)-2)
        %indexing to get correct pid traces when vial conc was decreasing
        %and odor conc was increasing in pid_multi_graph
        ind = [ind iC+1 iC];
        if iC==2*(size(mean_amps,1)-2)
            ind = [ind iC+2];
        end        
    end
    conc = struct(); amp_ratios = nan();
    figure; hold on
    set(gca,'YScale','log')
    title(strtrim(pidAn.odors(io).odor{1}))
    for iC = 1:(size(mean_amps,1)-1)
        amps_higherVial = amplitudes(~isnan(amplitudes(:,ind(2*iC-1))),ind(2*iC-1));
        amps_lowerVial = amplitudes(~isnan(amplitudes(:,ind(2*iC))),ind(2*iC));
        
        [h, p] = ttest2(amps_higherVial,amps_lowerVial);
        conc(iC).h = h;
        conc(iC).p = p;

        plot((2*iC-1)*ones(size(amps_higherVial)),amps_higherVial,'ok','MarkerSize',10,'LineWidth',3)
        plot((2*iC)*ones(size(amps_lowerVial)),amps_lowerVial,'ob','MarkerSize',10,'LineWidth',3)

%         figure; hold on
%         plot(PID_traces(:,ind(2*iC-1:2*iC))-std_traces(:,ind(2*iC-1:2*iC)),'Color',[0.6 0.6 0.6])
%         plot(PID_traces(:,ind(2*iC-1:2*iC))+std_traces(:,ind(2*iC-1:2*iC)),'Color',[0.6 0.6 0.6])
%         plot(PID_traces(:,ind(2*iC-1:2*iC)))

        amp_ratios(iC) = mean_amps_list(2*iC-1) / mean_amps_list(2*iC);
    end
    result(io).odor = pidAn.odors(io).odor;
    result(io).concs = conc;
    result(io).ratios = amp_ratios;
    
    % Print results
    fprintf('Amplitude ratios from high to low conc:\n')
    fprintf(repmat('  %4.2f   ', 1, numel(amp_ratios)),amp_ratios)
    fprintf('\np-values:\n')
    fprintf(repmat('  %4.4f  ', 1, numel(amp_ratios)),[conc.p])
    fprintf('\n')

end
aaa=345;
end



function [odors]=pid_all_series(trPid)
%make a structure with all the sets of stimuli,
%and plot and save the matrix of amp of response vs. concentration
%odor
% all the concentrations, all the liquid concentrations, all the
% dillutions
global lost_trials
%list of odors
odorList=unique({trPid.odor});


%all the trials for an odor
for io=1:numel(odorList)
%          if strncmp('mineral_oil',odorList(io),6)  %only perform analyses on odor stimuli
%              continue
%          end
    lost_trials = [];
    if any(strncmpi('mineral_oil',odorList,6)) %find N2 trials
        trialsMO = find(strcmp(odorList(strncmpi('mineral_oil',odorList,6)),{trPid.odor}));
        trPidMO  = trPid(trialsMO);
    else
        trPidMO = [];
    end
    
    trials=find(strcmp(odorList(io),{trPid.odor}));
    
    odors(io).odor     = odorList(io);
    odors(io).trials   = trials;
    odors(io).trPid    = trPid(trials);
    odors(io).odorConc = unique([trPid(trials).odorConc]);
    odors(io).vialConc = sort(unique([trPid(trials).vialConc]),2,'descend');
    odors(io).dillution= unique([trPid(trials).dillution]);
    odors(io).concPlot = pid_multi_graph( trPid, odors(io).odor, odors(io).odorConc, odors(io).vialConc, odors(io).dillution, trPidMO);
    odors(io).lost_trials = lost_trials;
    
    %if there are more than 1 vials with the same liquid dilution,
    %calculate their effective dilution (relative to highest conc).
    odors(io).equalConc= find(diff([odors(io).concPlot.amp(1:numel(odors(io).concPlot.vialConc),:)])<1E-9);
    concRate=ones(1,numel(odors(io).vialConc));
    if ~isempty(odors(io).equalConc)
        [~,indC]=sort(odors(io).concPlot.vialConc);
        concRate(1:end-1)=arrayfun(@(x) odors(io).concPlot.amp(x,odors(io).equalConc)/odors(io).concPlot.amp(indC(end),odors(io).equalConc),indC(1:end-1));
    end
    odors(io).concRate=concRate;
end
end


function [concPlot]=pid_multi_graph (pidStruct,odor,odorConc,vialConc,dillution, trPidMO )
%PID_multi_graph shows the relationship between concentration of a stimulus
%and the amplitude of the corresponding pid trace. 
%   
%   PID_multi_graph ( inputstruct, odor, odorConc, vialConc )
%
%   - Input structure is derived from the pid_get function.
%   - Odor is a string representing the odor for lookup
%   - odorConc is a matrix of the theoretical concentrations to be graphed
%   (read from the structure, which is read from the H5 file).
%   - vialConc is a matrix containing the vial concentrations to be
%   graphed. This is calculated from the reported concentration from the H5
%   file based on the (theoretical concentration) / (air dilution).
%
%   This program retrives sets of trials from the input structure with the
%   same input parameters. It collects the averages of these sets and
%   graphs them, allowing for comparison between vials and for assessment
%   of odor set concentration integrity. Sets with the same odorConc but
%   different vialConc are handled separately and graphed separately. If an
%   odorConc is not represented by an input vialConc, the combination is
%   ignored.
%
%   For example, if you want to graph an odorConc that is overlapping by 2
%   vials, you should input a scalar odorConc and a matrix of both
%   vialConc. If you want to graph several odorConc, some of which are
%   overlapping between vials, input the desired odorConc as a matrix with
%   each value represented once, and input all of the vialConc. The
%   overlapping values will be graphed twice, once for each vial, and the
%   non-overlapping values will be plotted only for the representitive
%   vials.
%
%   This program calls the PID_graph.m function. PID_graph.m is expecting
%   parameters defined by pid_test_protocol_0001.py. Changes to these
%   recording parameters requires changing the averaging windows defined in
%   PID_graph.m.
%
%   Written by CW, 29 August 2013.

% global suppressPlots

PID_timeseries = [];
std_timeseries =[];
amplitude = NaN(length(vialConc)*length(dillution),length(odorConc));
amp_distribution = [];
vialConcVec=[];
dilVec=[];
vialVec=[];
leg = {};
leg2 = {};

for i = 1:numel(dillution)
    for j=1:length(vialConc)
        leg2{end+1} = sprintf('[vial] = %0.3d',vialConc(j));
        vialConcVec = [vialConcVec vialConc(j)];
        dilVec      = [dilVec dillution(i)];
        vialVec     = [vialVec vial_lookup(pidStruct,odor,vialConc(j))];
    end
end

%Go through each measured stimulus, by each dilution, each vial, and each
%flow-ratio-produced concentration.
for di=1:numel(dillution)
    for vC = 1:length(vialConc)
        nstim(vC) = numel(unique([pidStruct((abs([pidStruct.vialConc]-vialConc(vC))<1E-9)& strncmp({pidStruct.odor},odor,6)).nitrogen]));
        for oC = 1:length(odorConc)
            PID_ts_i = nan;
            std_ts_i = nan;
            amplitude_i= nan;
            amp_distribution_i = nan(1,100);
            
            %if that concentration exists for that vC; gets the plot
            troCvC = (abs([pidStruct.odorConc]-odorConc(oC))<1E-9) & (abs([pidStruct.vialConc]-vialConc(vC))<1E-9) & strncmp({pidStruct.odor},odor,6) & [pidStruct.dillution]==dillution(di);
            if sum(troCvC)>1
                
                
                % Skip extra flow rate datapoints
                % Part of testing procedure to find fewest number of
                % datapoints/trials to get a solid estimate
%                 flows_fewest = [10 50 100];
                odorN2flow = pidStruct(find(troCvC,1)).nitrogen;
%                 if ~any(odorN2flow==flows_fewest)
%                     continue
%                 end
                
                % Get signals from N2 traces to send with call to pid_graph function
                if ~isempty(trPidMO)
%                     odorN2flow = pidStruct(find(troCvC,1)).nitrogen;
                    MO_pidStruct = trPidMO([trPidMO.nitrogen]==odorN2flow);
                else 
                    MO_pidStruct = [];
                end
                try
                    [PID_ts_i,std_ts_i,amplitude_i,amp_distribution_i] = pid_graph(pidStruct,odor,odorConc(oC),vialConc(vC),dillution(di),MO_pidStruct,1);
                catch
                    error('UNSUCCESSFUL RUN OF  *pid_graph*  FOR A STIMULUS')
                    aaa=234;
                end
                
                if ~isnan(PID_ts_i(1))
                    PID_timeseries(:,end+1) = PID_ts_i;
                    std_timeseries(:,end+1) = std_ts_i;
                    %remove datapoint of lowest flow of lowest conc vial 
                    if any(abs([6.171E-6 1.936E-5]-odorConc(oC))<1E-9)
                        amplitude_i = nan;
                    end
                    amplitude((di-1)*(length(vialConc))+vC,oC) = amplitude_i;
                    amp_distribution(:,end+1) = nan(100,1);
                    amp_distribution(1:length(amp_distribution_i),end) = amp_distribution_i';
                    
                    if iscell(odor)
                        odorName=odor{1};
                    else
                        odorName=odor;
                    end
                    leg{end+1} = sprintf('[conc] = %0.5d, [vial] = %0.3d',odorConc(oC),vialConc(vC));
                end
            end
        end
    end
end

%rectify: set to zero the negative amplitudes
amplitude(amplitude<0) = nan;
amp_distribution(amp_distribution<0) = 0;

%%% USE THIS TO CORRECT FOR CUTOFF IN SESS 048 ONLY
% if numel(vialConc)==2 && strncmp('menthone',odorName,6)
%     goodAmps =  find(~isnan(amplitude(1,:)));
%     goodAmps = goodAmps(1,1:end-1);
%     [~,fitParams(1,1),fitParams(1,2)] = powerLawFit(odorConc,amplitude(1,goodAmps),goodAmps);
%     replacement_amp = fitParams(1,1) * 0.1^fitParams(1,2);
%     amplitude(1,10) = replacement_amp;
% end

ampFit = nan(size(amplitude));
fitParams= nan(length(vialConc),2);
conc_colors = [];
vial_colors = flipud(hsv(numel(vialConc)));
for vC = 1:length(vialConc)
    shades = repmat(linspace(0.45,1,nstim(vC))',1,3);
    conc_colors = [conc_colors; repmat(vial_colors(vC,:),nstim(vC),1).*shades];
    if sum(~isnan(amplitude(vC,:)))<3
        continue
    else
        goodAmps =  find(~isnan(amplitude(vC,:)));
    %fit with power law to extrapolate to other vial's concentrations
        [ampFit(vC,:),fitParams(vC,1),fitParams(vC,2)] = powerLawFit(odorConc,amplitude(vC,goodAmps),goodAmps);
    end
end

% if ~suppressPlots
figure; hold on
plot([1:length(PID_timeseries)]-500,PID_timeseries-1.*std_timeseries,'Color',[0.75 0.75 0.75],'LineWidth',4)
plot([1:length(PID_timeseries)]-500,PID_timeseries+1.*std_timeseries,'Color',[0.85 0.85 0.85],'LineWidth',4)
pp = zeros(1,size(PID_timeseries,2));
for ip = 1:size(PID_timeseries,2)
    pp(ip) = plot([1:length(PID_timeseries)]-500,PID_timeseries(:,ip),'LineWidth',4,'Color',conc_colors(ip,:));
end
legend(pp,leg,'Location','best')
ylabel ('PID amplitude (mV)')
xlabel ('time (ms)')
title(odorName)
% set(gca,'FontSize',20)
hold off

figure; 
loglog((odorConc),ampFit,'k--')
hold on
set(gca,'ColorOrder',vial_colors)
pa=loglog(odorConc,amplitude,'o','MarkerSize',15,'LineWidth',3);
legend(pa,leg2,'Location','best')
ylabel('log mv')
xlabel('log concentration')
title(odorName)
xlim([min(odorConc)/10 1])
% loglog((odorConc),amplitudeFit,'k.-')
hold off
% end

% figure;
% plot(odorConc,amplitude,'d:','MarkerSize',12,'LineWidth',2)
% legend(leg2,'Location','best')
% ylabel('mv')
% xlabel('concentration')
% title(odorName)
% hold on
% plot((odorConc),ampFit,'k--')



concPlot.leg   = leg2;
concPlot.vialConc = vialConcVec;
concPlot.dil   = dilVec;
concPlot.vial  = vialVec;
concPlot.PIDtraces   = PID_timeseries;
concPlot.stdtraces   = std_timeseries;
concPlot.amp   = amplitude;
concPlot.ampDistr = amp_distribution;
concPlot.conc  = odorConc;
concPlot.fitParams = fitParams;




function [fitAmps,A,B] = powerLawFit(odorConc,amps,goodAmps)
    %%% CONSTRAIN B TO BE 1
% y = A x^B 
logx=log(odorConc(goodAmps)); 
logy=log(amps);

% p=lsqlin()

p=polyfit(logx,logy,1); 
B=p(1); 
% B=1;
A=exp(p(2)); 

fitAmps = A .* odorConc.^B;
end

end


function [ avg_pid_ts, std_ts, mean_timeaveraged_amplitude, amplitude ] = pid_graph( pidStruct, odor, odorConc, vialConc, dillution, MO_pidStruct, suppress_graphs)
%PID_GRAPH analyses a single odor,concentration,vialconcentration pair.
%   [average_pid_trace,mean_amplitude] = PID_graph (input_structure, ... 
%   odor, odorConc, vialConc, suppress_graphs).
%   
%   - Input structure is derived from the 'PID_file_read.m' function.
%   - Odor is a string representing the odor for lookup
%   - odorConc is the theoretical concentration (vial concentration * air
%   dilution
%   - vialConc is the vial concentration (this is calculated based on the
%   theoretical concentration provided by the H5 record file.
%   - suppress graphs allows suppression of graph output when calling this
%   function externally.
%
%   This finds all of the trials in the input structure matching the input
%   criteria, and graphs them for quality control. It preforms DC offset correction, 
%   finds amplitude of the PID signal, discards outlier, trials 
%   (outside 2 * SD of time averaged PID amplitude), and returns an average
%   PID signal trace and an average amplitude value for the trial set.
%
%   This relies on the timing set by pid_test_protocol_0001.py. Changes to
%   these parameters requires modification to the averaging windows.
%
%   Written by CW, 29 August 2013; modified by zk Dec 03, 2013
%   modified by kp

if nargin<6
    suppress_graphs=0;
end
len = numel(pidStruct);

global N_tr lost_trials
N_tr=[];


% calculate the vial concentration if it doesn't exist within the structure.
% This assumes a total flow of 1000 ml/min!!!!!!

if ~isfield(pidStruct,'vialConc')
    for i = 1:len
        pidStruct(i).vialConc = pidStruct(i).liqDilution ;
    end
end

% find all of the trials meeting the input criteria.
tr_selected = (abs([pidStruct.odorConc]-odorConc)<1E-9) & (abs([pidStruct.vialConc]-vialConc)<1E-9) & strncmp({pidStruct.odor},odor,6) & [pidStruct.dillution]==dillution;
tr_index = find(tr_selected);

%remove the trials with bad streams
missingStreams = arrayfun(@(x) sum([x.sniff]==0),pidStruct(tr_index));
badTrials = arrayfun(@(x) sum([x.sniff]==0)>350,pidStruct(tr_index));
lost_trials(1,end+1) = sum(badTrials); lost_trials(2,end) = numel(tr_index);
tr_index(badTrials)=[];

if sum(tr_index)<1
    avg_pid_ts=nan;
    mean_timeaveraged_amplitude=nan;
    mean_firstSniff_amplitude=nan;
    warning('No good trials found to satisfy conditions: odor %s, [theo] = %0.1d, from [liquid] = %0.1d, extra dil 1:%d', ...
        strtrim(odor{1}),odorConc,vialConc,dillution)
    return
end


%%%%%%%%%
% Pick N random trials - part of testing procedure to find fewest number of
% datapoints/trials to get solid estimates
if ~isempty(N_tr) %bootstrapping
    tr_index = datasample(tr_index,min(N_tr,numel(tr_index)),'Replace',false);
end


%%%%%%%%%
% Compile all of the odor trials' sniff recordings into a matrix.
numtrials = numel(tr_index);
pid_traces = zeros(length(pidStruct(1).sniff),numtrials);

for kt = 1:numtrials
    index = tr_index(kt);
    pid_traces(:,kt) = double(pidStruct(index).sniff);
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% if odor is 2-hydroxy, vial 0.0056
% MO_pidStruct(7) = [];
% pid_traces(:,7) = [];
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%subtract through all the presentation a straight line with the slope of the
%baseline prior to onset of fv.
baselineTimes = [1:pidStruct(tr_index(1)).fvOnTime]';
for kt = 1:numtrials
    baseLineFit = polyfit(double(baselineTimes),pid_traces(baselineTimes,kt),1);
    baseLineExtended = polyval(baseLineFit,1:size(pid_traces,1));
    
    pid_traces(:,kt) = pid_traces(:,kt) - baseLineExtended';
end



%%%%%%%%%
% Repeat procedure for N2 signal recording
if ~isempty(MO_pidStruct) && vialConc~=1
    MO_tr_index = 1:numel(MO_pidStruct);
    badTrials = arrayfun(@(x) sum([x.sniff]==0)>300,MO_pidStruct); %remove the trials with bad streams
    MO_tr_index(badTrials)=[];
    
    if ~isempty(N_tr) %bootstrapping
        MO_tr_index = datasample(MO_tr_index,min(N_tr,numel(MO_tr_index)),'Replace',false);
    end
    
    numtrials = numel(MO_tr_index);
    MO_pid_traces = zeros(length(MO_pidStruct(1).sniff),numtrials);
    
    for kt = 1:numtrials
        index = MO_tr_index(kt);
        MO_pid_traces(:,kt) = double(MO_pidStruct(index).sniff);
    end

    baselineTimes = [1:MO_pidStruct(MO_tr_index(1)).fvOnTime]';
    for kt = 1:numtrials
        baseLineFit = polyfit(double(baselineTimes),MO_pid_traces(baselineTimes,kt),1);
        baseLineExtended = polyval(baseLineFit,1:size(MO_pid_traces,1));

        baseline_avg = median(MO_pid_traces(baselineTimes,kt)) * ones(size(MO_pid_traces(:,kt)));
        MO_pid_traces(:,kt) = MO_pid_traces(:,kt) - baseLineExtended';
    end
    
    % remove outlier trials
    % Remove outliers by bin, not overall mean amp (just for plotting)
    pidMO_traces_binned=[];
    for itr = 1:size(MO_pid_traces,2)
        pidMO_traces_binned(:,itr) = mean(reshape(MO_pid_traces(:,itr)',100,size(MO_pid_traces,1)/100),1);
    end
    amp_binned = mean(pidMO_traces_binned,2);
    deviation_binned = std(pidMO_traces_binned,0,2);
    %
    % threshold = amp_binned + 2.5.* deviation_binned;
    % pid_traces_binned - repmat(threshold,1,size(pid_traces_binned,2))
    
    [ms,tr] = find(abs(pidMO_traces_binned - repmat(amp_binned,1,size(pidMO_traces_binned,2)))>2.5*repmat(deviation_binned,1,size(pidMO_traces_binned,2)));
    % if ~isempty(ms)
%     outlier_trials = [];
%     outlier_trials = unique(tr((50+100.*ms)>min(measureSegment)&(50+100.*ms)<max(measureSegment)));
%     presz = size(pid_traces,2);
    MO_pid_traces(:,unique(tr)) = [];
    
    
    average_MO_PIDtrace = mean(MO_pid_traces,2);
end
tr=[];

if ~suppress_graphs
    titlestr = sprintf('PID for %s, [theo] = %0.1d, from [liquid] = %0.1d, extra dil 1:%d', ...
        odor{1},odorConc,vialConc,dillution);
    
    figure;
    plot(pid_traces)
    title(titlestr);
    ylabel('mV')
    xlabel('ms');
    
    figure;
    surf(pid_traces);
    title(titlestr);
    ylabel('mV')
    xlabel('ms');
    zlabel('Trial number');
    x_on_line = [2500,4000];
    y_on_line = [0,0];
    annotation('line',x_on_line,y_on_line) 
end

% find the amplitude of the PID signal, find outliers and remove them.

%the segment for average is from 500 after onset of fv to 1000 before
%closing OR last saved value
endSegment     = pidStruct(tr_index(1)).fvOnTime + pidStruct(tr_index(1)).fvdur - 600;
measureSegment = double(pidStruct(tr_index(1)).fvOnTime) + (500 : min(endSegment,size(pid_traces,1)));
% measureSegment = double(pidStruct(tr_index(1)).fvOnTime) + (500 : min(2500,size(pid_traces,1)));

% titlestr = sprintf('conc = %2.5g, from vial = %2.5g', odorConc,vialConc);
% figure; hold on
% surf(pid_traces)
% colormap hot
% xlim([1 size(pid_traces,2)])
% title(titlestr,'FontSize',20)


% Subtract the avg mineral oil PID signal
if ~isempty(MO_pidStruct) && vialConc~=1
    pid_traces = pid_traces - average_MO_PIDtrace*ones(1,size(pid_traces,2));
end

% if strncmp(odor,'2-hydroxyac',6)
%     titlestr = sprintf('%s, conc = %0.5g, from vial = %0.5g', odor{1},double(odorConc),double(vialConc));
%     figure; hold on
%     plot(pid_traces,'k')
% %     plot(pid_traces(:,outlier_trs),'r')
%     % plot(pid_traces_binned,'b')
%     title(titlestr)
% end



% Remove outliers by bin, not overall mean amp (just for plotting)
pid_traces_binned=[];
for itr = 1:size(pid_traces,2)
    pid_traces_binned(:,itr) = mean(reshape(pid_traces(:,itr)',100,size(pid_traces,1)/100),1);
end
amp_binned = mean(pid_traces_binned,2);
deviation_binned = std(pid_traces_binned,0,2);

[ms,tr] = find(abs(pid_traces_binned - repmat(amp_binned,1,size(pid_traces_binned,2)))>2.5*repmat(deviation_binned,1,size(pid_traces_binned,2)));
outlier_trials = [];
outlier_trials = unique(tr((50+100.*ms)>min(measureSegment)&(50+100.*ms)<max(measureSegment)));
presz = size(pid_traces,2);
pid_traces(:,outlier_trials) = [];


amplitude = mean(pid_traces(measureSegment,:));  % assumes that the baseline is 0
deviation = std(amplitude);


% if strncmp(odor,'2-hydroxyac',6) && abs(double(odorConc)-0.000030855)<1e-9
%     avg_pid_pre_MOsubtr = mean(pid_traces,2);
%     
%     figure(9); clf; hold on
%     plot(avg_pid_pre_MOsubtr(1:5200),'r','LineWidth',5)
%     plot(average_MO_PIDtrace(1:5200),'Color',[0.5 0.5 0.5],'LineWidth',5)
%     
% end

% if strncmp(odor,'2-hydroxyac',6) && abs(double(odorConc)-0.00051)<1e-9
%     figure(1); clf; hold on
%     plot(pid_traces,'k')
%     plot(1:100:100*length(pid_traces_binned),amp_binned+2.5.*deviation_binned,'r')
% end



mean_timeaveraged_amplitude = mean(amplitude);

mean_firstSniff_amplitude = mean(mean(pid_traces(pidStruct(tr_index(1)).fvOnTime+150:pidStruct(tr_index(1)).fvOnTime+550,:)));

pid_ts = pid_traces';

if ~isempty(pid_ts(pid_ts==0))
    aaa=234;
end

avg_pid_ts = mean(pid_ts,1);
std_ts  = std(pid_ts);
high_pid_ts = avg_pid_ts + abs(std_ts);
low_pid_ts = avg_pid_ts - abs(std_ts);

aaa=234;

%     figure(10);
%     hold on;
%     plot(high_pid_ts,'Color',[.85,0.85,0.85]);
%     plot(low_pid_ts, 'Color',[.85,0.85,0.85]);
%     plot (avg_pid_ts,'Color','k');
% %     title(titlestr);
%     ylabel('mV');
%     xlabel('ms');
% %     hold off


% find the time-averaged deviation of each trial from the overall average.
% Make a scatter plot of these deviations to determine if there is a
% long-term shift

if ~suppress_graphs
    figure;
    plot(amplitude)
    ylabel('mV')
    xlabel('trial')
    title(titlestr);
    top = max(amplitude)*1.1;
    last = length(amplitude);
    axis([1,last,0,top]);
    
    % what I want from the end is a matrix with all the samples and all the
    % trials meeting these criteria. These matrices can be graphed as line
    % plots
    
end
end


function [ outstruct ] = pid_graph_all( inputstruct )
% Groups trials by odor & concentration and plots.
%   This allows a quick check for drift and 

outstruct = struct;

outstruct.Trials = inputstruct;

len = length(inputstruct);
outstruct.conc = [];
outstruct.od = {};



%%make a vector for the odors and concentrations to use for masking trials
%%based on their properties.
for kt = 1:len
    
    outstruct.od(end+1)   = cellstr(inputstruct(kt).odor);
    outstruct.conc(end+1)  = inputstruct(kt).odorConc;

end


outstruct.concentrationlist = unique(outstruct.conc);
outstruct.odorlist = unique(outstruct.od);


% make indeces of each odor:concentration pair. Make a structure element f

iO = [];
iC = [];



for ko = 1:length(outstruct.odorlist)
    
    odorvar = genvarname(outstruct.odorlist{ko});
    outstruct.(odorvar) = {};
    
    
    for kt = 1:len
        if isequal(outstruct.odorlist(ko),outstruct.od(kt))
            iO(kt) = 1;
        else
            iO(kt) = 0; 
        end 
    end
    
    iO = logical(iO);
    
    for kc = 1:length(outstruct.concentrationlist)
        
        iC = (outstruct.conc == outstruct.concentrationlist(kc));
        
        intersection = iO .* iC;
        outstruct.(odorvar){kc} = find(intersection);
   
    end
end


% great. now you've done that easy stuff. Let's plot each individual trace, making a figure for each odor:concentration pair. This will help us determine if the odor signal was consient through the session.

for ko = 1:length(outstruct.odorlist)
    
    odorvar = genvarname(outstruct.odorlist{ko});

    for kc = 1:length(outstruct.(odorvar))
        
        sniffmat = [];        
        
        ind = outstruct.(odorvar){kc};
        
        for kts = 1:length(ind)
            
            sniffmat(:,kts) = outstruct.Trials(ind(kts)).sniff;
        end
        
            
        
        figure;
        lentrial = length(sniffmat);
        x = linspace(1,lentrial,lentrial);
        offset = mean(sniffmat([1:500],:));
        
        for offf = 1:length(offset)
            sniffmat(:,offf) = sniffmat(:,offf) - offset(offf);
        end
        
        plot (x,sniffmat)
        titlestr1 = sprintf(' %d concentration ',outstruct.concentrationlist(kc));
        titlestr2 = [odorvar, titlestr1];
        title(titlestr2)
    end

end
end


function pull_data(mouse, sess, stat)
% gets the data from mouse and session from the recording station stat
fprintf('Pulling data from station %s \n',stat);
fprintf('============================================================\n')
fn  = file_names(mouse, sess,'',stat);

%check existence of folder in the station, and if it is mounted
if ~exist(fn.fold_sd_data, 'dir')
    error(['no raw data folder (raw_data) in station ' stat '. Is it mounted?'])
end

if ~exist(fn.fold_sd_mouse, 'dir')
    error(['no mouse ' mouse ' in station ' stat])
end

if ~exist(fn.fold_sd_sess, 'dir')
    error(['no session ' sess ' in station ' stat]);
end

%check target folder (raw data)

if ~exist(fn.fold_rd_mouse, 'dir')
    mkdir(fn.fold_rd_mouse)
end

if ~exist(fn.fold_rd_sess, 'dir')
    mkdir(fn.fold_rd_sess)
end

% copy files one by one
fl=dir(fn.fold_sd_sess);
if numel(fl)<3
    error(['No files in ' fn.fold_sd_sess]);
end

isub=[fl(:).isdir];
nameFolds = {fl(isub).name}';
fl(ismember(nameFolds,{'.','..'})) = [];
nameFolds(ismember(nameFolds,{'.','..'})) = [];

fprintf('Copying %d files (incl %d folders) from %s  \n to %s \n',numel(fl),numel(nameFolds),fn.fold_sd_sess,fn.fold_rd_sess);
fprintf('===========================================================================\n')
tic;

for ifl = 1:numel(fl)
    source=fullfile(fn.fold_sd_sess,fl(ifl).name);
    dest=fn.fold_rd_sess;
    FileOrFolder='File';
    if(fl(ifl).isdir)
        dest=fullfile(fn.fold_rd_sess,fl(ifl).name);
        if ~exist(dest,'dir')
            mkdir(dest);
        end
        FileOrFolder='*(Folder)';
    end
    fprintf('%s %2d:\t %24s %5d Mb...',FileOrFolder,ifl,fl(ifl).name,round(fl(ifl).bytes/1000000));
    [status]=copyfile(source,dest);
    if ~status
        error(['Error copying ' source]);
    end
    fprintf(' ok \t %5d \n',round(toc));
end



fprintf('Done fetching files. \n');
fprintf('===========================================================================\n')
end



function trPid=pid_get(mouse,sess,rec)
% This function reads an h5 file with PID traces recorded in the sniff
% channel.

var(1)  = struct('new', 'trialNum',   'old', 'trialNumber', 'relative', 0);
var(2)  = struct('new', 'trialstart', 'old', 'starttrial',  'relative', 0);
var(3)  = struct('new', 'trialEnd',   'old', 'endtrial',    'relative', 0);
var(4)  = struct('new', 'fvOnTime',   'old', 'fvOnTime',    'relative', 1);
var(5)  = struct('new', 'fvdur',      'old', 'fvdur',       'relative', 0);
var(6)  = struct('new', 'odor',       'old', 'odor',        'relative', 0);
var(7)  = struct('new', 'vial',       'old', 'vial',        'relative', 0);
var(8)  = struct('new', 'vialConc',   'old', 'vialconc',    'relative', 0);
var(9)  = struct('new', 'air',        'old', 'AirFlow_1',   'relative', 0);
var(10) = struct('new', 'nitrogen',   'old', 'NitrogenFlow_1','relative', 0);
var(11) = struct('new', 'odorConc',   'old', 'odorconc',    'relative', 0);
var(12) = struct('new', 'dillution',  'old', 'dillution',   'relative', 0);

% number of fields referring to trial start and end in the variables
% description var() struct:
nTrEndField   = 3;
nTrStartField = 2;
nFVonField    = 4;

brEvents  = { 'breaks'};
streams = {'sniff'};

if isnumeric(mouse)
    mouse=sprintf('%04d',mouse);
end

fn = file_names(mouse,sess,rec);
fileNames=[fn.rd_rec_bn '*_beh.h5'];
filesList=dir(fullfile(fn.fold_rd_sess,fileNames));

file=fullfile(fn.fold_rd_sess,filesList(1).name);
%assuming only one file; reads just the first file.

dispname = strcat('reading: ',file);
disp(dispname);

info = h5info(file);
n_tr = numel(info.Groups);

table_name = info.Datasets.Name;
table = h5read(file,['/', table_name]);
table.odor = table.odor';

[stream.sniff, event.breaks]  = build_continious_sniff();

trPid = build_trial_structure(var, brEvents, streams);

    % ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    function [sn, breaks] = build_continious_sniff()
        % read continious sniff waveform and check the packets interuption
        % sn - continious waveform. if there is a missing packet sn is
        % performs 1st order butterworth filter
        % padded by zeros
        % breaks - [2,nb] - sequence of missing chunks of data onset, offset
        trEndField=var(nTrEndField).old;
        
        adc_const = 5000.0/2047; % convert factor for ADC to mV from the sniff amplifier. Only necessary for files after 20130805.
        
        lasTrial=find((table.(trEndField)>0),1,'last');
        preSize =table.(trEndField)(lasTrial)+1E6;
        
        disp('reading all pid packets...')
        sample_on = zeros(1,preSize);
        sn_unfiltered = zeros(1,preSize);        
     
        Fs = 1000;  % Sampling Frequency
        
        for kt = 1:n_tr
            group_name = info.Groups(kt).Name; 
            Events        = h5read(file, [group_name,'/Events']);
            sniffPackets  = h5read(file, [group_name,'/sniff']);
            
            for ie = 1:numel(Events.packet_sent_time)
                nt  = int32(numel(sniffPackets{ie}));
                ind = Events.packet_sent_time(ie) - nt-1 +(1:nt);
                if ind == 0
                    continue
                end
                sn_unfiltered(ind) = sniffPackets{ie};
                sample_on(ind) = 1;
            end
        end
        
        ind_end = ind(end)+0;
        disp (ind_end)
        disp (length(sn_unfiltered))
        sn_unfiltered = sn_unfiltered(1:ind_end);
        
        sn = zeros(1,ind_end);
        sn = sn_unfiltered*adc_const;
        
        breaks_on  = find(diff(sample_on)==-1);
        breaks_off = find(diff(sample_on)==1);
        
        %breaks_on = [1,breaks_on]; %starts on at first sample
        
        %checks if the first on value is greater than the first off,
        %indicating that the sample started on at 1. If the sample started off,
        %then the first on will be the first value in the array.
        if breaks_on(1) > breaks_off(1)
            breaks_on = [1,breaks_on];
        end
        
        % checks if sample is 'on' at the end, if it is, then it forces it
        % off at the last sample.
        if breaks_on(end) > breaks_off(end) 
           breaks_off = [breaks_off, ind_end];
        end
        
        nb  = numel(breaks_on);
        
        breaks = [breaks_on(:)'; breaks_off(:)'];
    end
    
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    function tr = build_trial_structure(var, allEvents, streams)
        nt = numel(table.(var(1).old));
        t_pre  = 500;
        trial_record_length = 4999; %making all the trial chunks 6 seconds in duration
        errors = [];
        trStartField=var(nTrStartField).old;   
        fvOnTime = var(nFVonField).old;
        trEndTime = var(nTrEndField).old;
        it=0;
        for kt = 1:nt,
            
            t1 = table.(trStartField)(kt) - t_pre;
            
            %checks if trialstart is a number, if not, continues.
            if ~table.(trStartField)(kt) || (table.(trEndTime)(kt)-table.(fvOnTime)(kt))<table.fvdur(kt)
                kts=num2str(kt);
                error_kt = ['error with trial ' , kts, ', skipping...'];
                disp(error_kt);
                errors=[errors,kt];
                continue
            end
                
            it=it+1;

            % record all varibles
            for kv = 1:numel(var)
                tr(it).(var(kv).new) = table.(var(kv).old)(kt,:);
                if var(kv).relative
                    tr(it).(var(kv).new) = tr(it).(var(kv).new) - t1; %table.starttrial(kt);
                end
            end
            
            t2 = tr(it).trialstart + trial_record_length;
                        
            %checks if the trial should end after the streams
            if t2>numel(stream.(streams{1}))
                kts=num2str(kt);
                error_kt = ['streams ended before trial ' , kts, ', ending trial structure building...'];
                disp(error_kt);
                errors=[errors,kt];
                tr(it)=[];
                break
            end
            
            % record all events
            for ke = 1:numel(allEvents)
                ind = (event.(allEvents{ke})(1,:)>=t1)&(event.(allEvents{ke})(2,:)<=t2);
                tr(it).(allEvents{ke}) = event.(allEvents{ke})(:,ind) - double(t1);  %double(tr(kt).starttrial);
            end
            
            % all streams
            for ks = 1:numel(streams)
                tr(it).(streams{ks}) = stream.(streams{ks})(t1:t2); 
            end
        end
%         tr(1) = [];
    end
end



function vial = vial_lookup(trPid,odor,vialConc)
%lookup the vial that has that odor at that concentration, to 6 digits
trialsThisOC=find(round(100000*[trPid.vialConc])==round(100000*vialConc) & strncmp({trPid.odor},odor,6));
vial=unique([trPid(trialsThisOC).vial]);
vialConc = double(vialConc);
if numel(vial)>1
    warning('There were %d vials of %s with concentration %4.4f \n', numel(vial), odor{1}, vialConc);
    vial=vial(1);
end

if isempty(vial)
        error('There were no vials of %s with concentration %f \n', odor{1}, vialConc);
end

end


function [gf, gs] = subplot_fig(ny, nx, fig)
    if exist('fig', 'var')
        gf = figure(fig); clf
    else
        gf = figure;
    end
    
    dx = 0.9/nx;    dy = 0.9/ny;
    wx = dx*0.95;   wy = dy*0.95;
    for ix = 1:nx
        for iy = 1:ny
            gs(iy,ix) = subplot('position', [0.08+(ix-1)*dx, 0.95-iy*dy, wx, wy]);
        end
    end
end
